# -*- coding: utf-8 -*-
"""Gruppo5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XuwEtECW7oIKCn49Dc9ja870Cbi9Copp
"""

import numpy as np
import pandas as pd
from scipy.special import kv
from scipy.fft import fft
import scipy.interpolate as interpolate

rf=1.9/100
q=1.2/100
S0=1124.47

alpha= 3.8288
beta= -3.8286
delta= 0.2375
v= -1.7555


def EX_psi(u,alpha,beta,delta,v):   
    """funzione psi dal testo dell'esercizio"""
    
    f1= ((alpha**2-beta**2)/(alpha**2-(beta+1j*u)**2))**(v/2)
    f2_num=kv(v,delta*np.sqrt(alpha**2-(beta+1j*u)**2))
    f2_den=kv(v,delta*np.sqrt(alpha**2-beta**2))
    
    return np.log(f1*(f2_num/f2_den))

def get_cf(u,alpha,beta,delta,v,T):
    """risk-neutral characteristic function of log_price"""
    
    f1=(rf-q-EX_psi(-1j,alpha,beta,delta,v))
    f2=EX_psi(u,alpha,beta,delta,v)
    
    return np.exp( 1j*u*f1*T+f2*T )

# utilizziamo il metodo dei trapezi e calcoliamo i pesi di conseguenza
N= 2**12
CM_alpha= 1.5
CM_eta= 0.25
CM_lambda = (2*np.pi)/(N*CM_eta)
b= (CM_lambda*N)/2
weight= np.array([0.5] + [1 for i in range(1,N-1)] + [0.5])*CM_eta
k= -b+CM_lambda*np.array( [n for n in range(N)] )
u= CM_eta*np.array([j for j in range(N)])


def CM_psi(u,alpha,beta,delta,v,T):
    """psi di carmadan utile per computare fft"""
    
    psi_num = get_cf(u-(1+CM_alpha)*1j,alpha,beta,delta,v,T)
    psi_den = CM_alpha**2+CM_alpha-u**2+1j*(2*CM_alpha+1)*u
    
    return np.exp(-rf*T)*(psi_num/psi_den)
    
dk=5
K= np.arange(975,1500+dk,dk)

def get_price(u,alpha,beta,delta,v,T):   
    """funzione per tornare la curva dei prezzi"""
    
    H= [ np.exp(1j*b*x)*CM_psi(x,alpha,beta,delta,v,T) for x in u ]*weight
    mod_prices= (1/np.pi*np.exp(-CM_alpha*k-rf*T)*fft(H)).real
    
    price_FFT = S0*mod_prices
    KFFT = S0*np.exp(k)
    
    return interpolate.CubicSpline(KFFT,price_FFT,bc_type='natural')(K)


from matplotlib import pyplot as plt

def Table_price(alpha,beta,delta,v):
    """computa i prezzi derivanti dal modello GH"""
    
    T_price=np.eye(20,106)
    for t in range(1,21):
        T_price[t-1]=get_price(u,alpha,beta,delta,v,t/20)
        
    return T_price
   
Shoutens= pd.read_csv("Shoutens.txt",sep="\t",index_col="strk")
Shoutens.index.name="Strike"
Shoutens.columns.name="Maturity"

def Table_price_data(alpha,beta,delta,v):
    """
    computa un pandas DataFrame considerando solo le colonne
    presenti in Shoutens per gli strike dati
    """
    
    T_price_data=pd.DataFrame(Table_price(alpha,beta,delta,v).transpose(),index=K,columns=range(1,21))

    month=np.array(["jan","feb","march","april","may","june","july","aug","sep","oct","nov","dec"])
    year=np.array(["2002","2003"])

    T_price_data.index.name="Strike"
    T_price_data.columns= [ month[n-1]+year[0] for n in range(5,13) ] + [ month[n]+year[1] for n in range(12) ]
    T_price_data.columns.name="Maturity"

    T_price_data=T_price_data.get( Shoutens.columns )
    
    return T_price_data


def residual(args):
    """computa i residui da usare in least_squares"""
    
    alpha, beta, delta, v= args
    
    tmp=(Shoutens-Table_price_data(alpha,beta,delta,v)).replace(np.nan,0).to_numpy()
    tmp=tmp[tmp!=0]
    
    return tmp

import scipy

lb=[alpha,-alpha+0.0001,0,-np.inf]
ub=[np.inf,alpha-0.0001,np.inf,0]

#lb=[-np.inf,-np.inf,0.001,-np.inf]
#ub=[np.inf,np.inf,np.inf,-0.001]
    
optimized= scipy.optimize.least_squares(residual,(alpha,beta,delta,v),
                                    #constraints=(
    #{ "type":"ineq","fun":lambda x: x[0]-0.001-abs(x[1]) },
    #{ "type":"ineq","fun":lambda x: x[2]-0.001 },
    #{ "type":"ineq","fun":lambda x: -x[3]-0.001 }
    #),
                                    bounds=(lb,ub)
                                    )


#grafico con valori Shoutens
T_price=Table_price(alpha,beta,delta,v) 
T_price_data=Table_price_data(alpha,beta,delta,v)

fig1=plt.figure(figsize=(15,10))
ax1=fig1.add_axes([0,0,1,1],projection="3d")

t=np.linspace(1,20,20)
X,Y=np.meshgrid(K,t)

surf1=ax1.plot_surface(X,Y,T_price,cmap="gnuplot",shade=True)
fig1.colorbar(surf1, shrink=0.5, aspect=5)
ax1.view_init(30,45)

ax1.set_xlabel("Strikes",weight="bold",size=15)
ax1.set_ylabel("Time to Maturity (month)",weight="bold",size=15)
ax1.set_zlabel("Prices",weight="bold",size=15)

#grafico con valori calibrati

opt_x=optimized.get("x")

T_price2=Table_price(opt_x[0],opt_x[1],opt_x[2],opt_x[3]) 
T_price_data2=Table_price_data(opt_x[0],opt_x[1],opt_x[2],opt_x[3])

fig2=plt.figure(figsize=(15,10))
ax2=fig2.add_axes([0,0,1,1],projection="3d")

surf2=ax2.plot_surface(X,Y,T_price2,cmap="gnuplot",shade=True)
fig2.colorbar(surf2, shrink=0.5, aspect=5)
ax2.view_init(30,45)

ax2.set_xlabel("Strikes",weight="bold",size=15)
ax2.set_ylabel("Time to Maturity (month)",weight="bold",size=15)
ax2.set_zlabel("Prices",weight="bold",size=15)


    
#calcolo della pdf
from scipy import integrate

F= lambda x: integrate.quad( 
    lambda u,x: 1/np.pi *np.exp(-1j*u*x)*get_cf(u,alpha,beta,delta,v,3/20)
    ,0,np.inf,args=(x))

x=np.linspace(-40,40,400)
F0= [F(t)[0] for t in x]

plt.plot(x,F0)